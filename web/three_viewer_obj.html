<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js OBJ Viewer</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: #f5f5f500;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body>
    <div id="container"></div>
    <div id="loading">Loading 3D models...</div>
    <script>
        function queryParam(name) {
            const params = new URLSearchParams(window.location.search);
            return params.get(name);
        }

        // NEW: Support for separate assembly and disassembly model groups
        // Query params: 
        // - assemblyModels=<enc1>,<enc2>
        // - assemblyMtls=<enc1>,<enc2>
        // - disassemblyModels=<enc1>,<enc2>
        // - disassemblyMtls=<enc1>,<enc2>
        // - mode=assemble|disassemble (initial mode)
        
        const assemblyModelsParam = queryParam('assemblyModels');
        const assemblyMtlsParam = queryParam('assemblyMtls');
        const disassemblyModelsParam = queryParam('disassemblyModels');
        const disassemblyMtlsParam = queryParam('disassemblyMtls');
        const initialMode = queryParam('mode') || 'assemble';
        
        const assemblyModels = assemblyModelsParam ? assemblyModelsParam.split(',').map(decodeURIComponent).filter(Boolean) : [];
        const assemblyMtls = assemblyMtlsParam ? assemblyMtlsParam.split(',').map(decodeURIComponent).filter(Boolean) : [];
        const disassemblyModels = disassemblyModelsParam ? disassemblyModelsParam.split(',').map(decodeURIComponent).filter(Boolean) : [];
        const disassemblyMtls = disassemblyMtlsParam ? disassemblyMtlsParam.split(',').map(decodeURIComponent).filter(Boolean) : [];

        console.log('three_viewer: assemblyModels=', assemblyModels);
        console.log('three_viewer: disassemblyModels=', disassemblyModels);
        console.log('three_viewer: initialMode=', initialMode);

        const loadingEl = document.getElementById('loading');
        function setLoadingText(msg) {
            if (loadingEl) loadingEl.innerText = msg;
            console.log(msg);
        }

        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = null;

        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
        camera.position.set(2, 2, 2);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const dpr = Math.min(window.devicePixelRatio ? window.devicePixelRatio : 1, 2);
        renderer.setPixelRatio(dpr);
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);

        function resizeRenderer() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const resizeObserver = new ResizeObserver(() => {
            resizeRenderer();
        });
        resizeObserver.observe(container);

        setTimeout(() => {
            resizeRenderer();
        }, 100);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        // Limit vertical rotation angle (polar angle)
        // 0 = straight down, PI = straight up, PI/2 = horizon
        controls.minPolarAngle = Math.PI * 0.15; // ~27째 from top (prevent looking straight down)
        controls.maxPolarAngle = Math.PI * 0.85; // ~153째 from top (prevent looking straight up)
        
        console.log('three_viewer: Vertical viewing angle limited to', 
                    Math.round(controls.minPolarAngle * 180 / Math.PI), '째 to', 
                    Math.round(controls.maxPolarAngle * 180 / Math.PI), '째');

        // Lighting
        const ambient = new THREE.AmbientLight(0xffffff, 0.25);
        scene.add(ambient);
        const dir = new THREE.DirectionalLight(0xffffff, 1.0);
        dir.position.set(10, 10, 10);
        scene.add(dir);
        const rim = new THREE.PointLight(0xffffff, 0.6);
        rim.position.set(-5, 5, -5);
        scene.add(rim);

        // Create separate groups for assembly and disassembly
        const assemblyGroup = new THREE.Group();
        assemblyGroup.name = 'assemblyGroup';
        const disassemblyGroup = new THREE.Group();
        disassemblyGroup.name = 'disassemblyGroup';

        // Track current mode
        let currentMode = initialMode;

        // Function to toggle between modes
        function setMode(mode) {
            currentMode = mode;
            assemblyGroup.visible = (mode === 'assemble');
            disassemblyGroup.visible = (mode === 'disassemble');
            console.log('three_viewer: switched to mode', mode);
        }

        // Listen for messages from Flutter to toggle mode
        window.addEventListener('message', function(event) {
            try {
                const data = event.data;
                let type, mode;
                
                if (typeof data === 'string') {
                    const parsed = JSON.parse(data);
                    type = parsed.type;
                    mode = parsed.mode;
                } else if (typeof data === 'object') {
                    type = data.type;
                    mode = data.mode;
                }

                if (type === 'toggleMode' && mode) {
                    setMode(mode);
                }
            } catch (e) {
                // Ignore malformed messages
            }
        });

        // Load all models for both groups
        let totalModelsToLoad = assemblyModels.length + disassemblyModels.length;
        let loadedCount = 0;

        function updateLoadingProgress() {
            loadedCount++;
            setLoadingText(`Loading models... ${loadedCount}/${totalModelsToLoad}`);
            
            if (loadedCount === totalModelsToLoad) {
                // All models loaded, finalize setup
                finalizeSetup();
            }
        }

        function finalizeSetup() {
            console.log('three_viewer: Finalizing setup...');
            console.log('three_viewer: assemblyGroup has', assemblyGroup.children.length, 'children');
            console.log('three_viewer: disassemblyGroup has', disassemblyGroup.children.length, 'children');
            
            // Scale each group to fit viewport, but preserve Blender origin
            [assemblyGroup, disassemblyGroup].forEach(group => {
                if (group.children.length > 0) {
                    // Calculate bounding box for the entire group
                    const box = new THREE.Box3().setFromObject(group);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);
                    
                    console.log('three_viewer: Group', group.name, 'bounding box size:', size, 'maxDim:', maxDim);
                    
                    // DON'T center the group - respect Blender's origin positioning
                    // group.position.sub(center); // REMOVED - this was shifting everything
                    
                    // Only scale to fit viewport (1.5 units)
                    const scale = maxDim > 0 ? (1.5 / maxDim) : 1.0;
                    group.scale.setScalar(scale);
                    
                    console.log('three_viewer: Group', group.name, 'scaled to:', scale);
                    console.log('three_viewer: Group', group.name, 'position (preserved from Blender):', group.position);
                    console.log('three_viewer: Group', group.name, 'children count:', group.children.length);
                }
            });

            // Apply exploded view displacement to disassembly group
            // IMPORTANT: Calculate displacement based on each object's geometry center
            // You can adjust these multipliers to control explosion on each axis
            const explosionMultiplierX = 1.5; // 0.5 = 1.5x distance on X axis
            const explosionMultiplierY = 0.5; // 0.5 = 1.5x distance on Y axis
            const explosionMultiplierZ = 0.5; // 0.5 = 1.5x distance on Z axis
            
            if (disassemblyGroup.children.length > 0) {
                disassemblyGroup.children.forEach(function(child) {
                    // Calculate the center of this object's geometry
                    const box = new THREE.Box3().setFromObject(child);
                    const center = new THREE.Vector3();
                    box.getCenter(center);
                    
                    // Calculate displacement with per-axis multipliers
                    const displacement = new THREE.Vector3(
                        center.x * explosionMultiplierX,
                        center.y * explosionMultiplierY,
                        center.z * explosionMultiplierZ
                    );
                    
                    // Apply the displacement to the object's position
                    child.position.add(displacement);
                    
                    console.log('three_viewer: Displaced', child.name || 'object', 
                                'center at', center.length().toFixed(2), 
                                'by', displacement.length().toFixed(2), 'units');
                });
                
                console.log('three_viewer: Applied exploded view to disassembly group');
            }

            // Add both groups to scene
            scene.add(assemblyGroup);
            scene.add(disassemblyGroup);

            // Set initial visibility
            setMode(currentMode);

            loadingEl.style.display = 'none';
            startLoop();
            console.log('three_viewer: All models loaded and ready!');
            console.log('three_viewer: Assembly group visible:', assemblyGroup.visible);
            console.log('three_viewer: Disassembly group visible:', disassemblyGroup.visible);
        }

        function loadModelGroup(models, mtls, targetGroup) {
            if (models.length === 0) {
                // No models to load for this group
                return;
            }

            function loadSingleModel(idx) {
                if (idx >= models.length) {
                    return; // Done with this group
                }

                const path = models[idx];
                const lower = path.toLowerCase();
                const encodedPath = encodeURI(path);

                const finalize = function (obj) {
                    obj.userData = obj.userData || {};
                    obj.userData.source = path;
                    obj.traverse(function (child) {
                        if (child.isMesh) {
                            child.userData = child.userData || {};
                            child.userData.source = path;
                        }
                    });
                    targetGroup.add(obj);
                    updateLoadingProgress();
                    loadSingleModel(idx + 1);
                };

                if (lower.endsWith('.glb') || lower.endsWith('.gltf')) {
                    const gltfLoader = new THREE.GLTFLoader();
                    gltfLoader.load(encodedPath, function (gltf) {
                        const obj = gltf.scene || gltf.scenes[0];
                        finalize(obj);
                    }, null, function (err) {
                        console.error('GLTF load error for', encodedPath, err);
                        updateLoadingProgress();
                        loadSingleModel(idx + 1);
                    });
                } else {
                    const mtlToUse = mtls[idx] || null;
                    const onObjLoaded = function (obj) {
                        obj.traverse(function (child) {
                            if (!child.isMesh || !child.material) return;
                            const mat = child.material;
                            
                            // If already a standard material, just update it
                            if (mat.type === 'MeshStandardMaterial') { 
                                mat.needsUpdate = true; 
                                return; 
                            }
                            
                            // Convert to MeshStandardMaterial with proper PBR values
                            const std = new THREE.MeshStandardMaterial({ 
                                color: mat.color ? mat.color.clone() : new THREE.Color(0xcccccc),
                                side: THREE.DoubleSide,
                                metalness: 0.1,
                                roughness: 0.8,
                            });
                            
                            // Copy textures from MTL material
                            if (mat.map) std.map = mat.map;
                            if (mat.bumpMap) std.normalMap = mat.bumpMap;
                            if (mat.normalMap) std.normalMap = mat.normalMap;
                            if (mat.specularMap) std.roughnessMap = mat.specularMap;
                            if (mat.envMap) std.metalnessMap = mat.envMap;
                            if (mat.metalnessMap) std.metalnessMap = mat.metalnessMap;
                            
                            if (std.metalnessMap) std.metalness = 0.5;
                            if (std.roughnessMap) std.roughness = 0.9;
                            if (std.normalMap) std.normalScale = mat.normalScale || new THREE.Vector2(1, 1);
                            
                            std.opacity = mat.opacity !== undefined ? mat.opacity : 1.0;
                            std.transparent = !!mat.transparent;
                            std.needsUpdate = true;
                            child.material = std;
                        });
                        finalize(obj);
                    };

                    const loadObjWithMaterials = function (materials) {
                        const objLoader = new THREE.OBJLoader();
                        if (materials) objLoader.setMaterials(materials);
                        objLoader.load(encodedPath, onObjLoaded, null, function (err) {
                            console.error('OBJ load error for', encodedPath, err);
                            updateLoadingProgress();
                            loadSingleModel(idx + 1);
                        });
                    };

                    if (mtlToUse) {
                        const encodedMtl = encodeURI(mtlToUse);
                        const mtlLoader = new THREE.MTLLoader();
                        mtlLoader.load(encodedMtl, function (materials) {
                            materials.preload();
                            loadObjWithMaterials(materials);
                        }, null, function (err) {
                            console.warn('MTL load failed for', encodedMtl, err);
                            loadObjWithMaterials(null);
                        });
                    } else {
                        loadObjWithMaterials(null);
                    }
                }
            }

            loadSingleModel(0);
        }

        // Start loading both groups
        if (totalModelsToLoad === 0) {
            setLoadingText('No models specified');
        } else {
            loadModelGroup(assemblyModels, assemblyMtls, assemblyGroup);
            loadModelGroup(disassemblyModels, disassemblyMtls, disassemblyGroup);
        }

        // Raycaster for click detection
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function onPointerDown(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            if (intersects && intersects.length) {
                const top = intersects[0].object;
                const source = top.userData && top.userData.source ? top.userData.source : 
                              (top.parent && top.parent.userData ? top.parent.userData.source : null);
                if (source) {
                    window.parent.postMessage({ type: 'partClick', model: source }, '*');
                }
            }
        }

        renderer.domElement.addEventListener('pointerdown', onPointerDown);

        // Animation loop
        let rafId = null;
        let running = !document.hidden;
        function startLoop() {
            function animate() {
                if (!running) return;
                rafId = requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            if (running) animate();
        }

        document.addEventListener('visibilitychange', function () {
            running = !document.hidden;
            if (running && !rafId) startLoop();
            if (!running && rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
        });

        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>