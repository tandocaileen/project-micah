<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js OBJ Viewer</title>
    <style>
        html,
        body {
            margin: 0;
            height: 100%;
            background: #f5f5f500;
        }

        #container {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #333;
        }

        #tooltip {
            position: absolute;
            display: none;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
            white-space: nowrap;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
</head>

<body>
    <div id="container"></div>
    <div id="loading">Loading 3D models...</div>
    <div id="tooltip"></div>
    <script>
        function queryParam(name) {
            const params = new URLSearchParams(window.location.search);
            return params.get(name);
        }

        // NEW: Support for separate assembly and disassembly model groups
        // Query params: 
        // - assemblyModels=<enc1>,<enc2>
        // - assemblyMtls=<enc1>,<enc2>
        // - disassemblyModels=<enc1>,<enc2>
        // - disassemblyMtls=<enc1>,<enc2>
        // - mode=assemble|disassemble (initial mode)

        const assemblyModelsParam = queryParam('assemblyModels');
        const assemblyMtlsParam = queryParam('assemblyMtls');
        const disassemblyModelsParam = queryParam('disassemblyModels');
        const disassemblyMtlsParam = queryParam('disassemblyMtls');
        const initialMode = queryParam('mode') || 'assemble';
        const disassemblyDistanceParam = queryParam('disassemblyDistance');

        const assemblyModels = assemblyModelsParam ? assemblyModelsParam.split(',').map(decodeURIComponent).filter(Boolean) : [];
        const assemblyMtls = assemblyMtlsParam ? assemblyMtlsParam.split(',').map(decodeURIComponent).filter(Boolean) : [];
        const disassemblyModels = disassemblyModelsParam ? disassemblyModelsParam.split(',').map(decodeURIComponent).filter(Boolean) : [];
        const disassemblyMtls = disassemblyMtlsParam ? disassemblyMtlsParam.split(',').map(decodeURIComponent).filter(Boolean) : [];
        let disassemblyDistance = disassemblyDistanceParam ? parseFloat(disassemblyDistanceParam) : 1.0;

        console.log('three_viewer: assemblyModels=', assemblyModels);
        console.log('three_viewer: disassemblyModels=', disassemblyModels);
        console.log('three_viewer: initialMode=', initialMode);

        const loadingEl = document.getElementById('loading');
        function setLoadingText(msg) {
            if (loadingEl) loadingEl.innerText = msg;
            console.log(msg);
        }

        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xe0e0e0); // Light gray background

        const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
        camera.position.set(3, 1, 2.5); // Front-right angle, lower height to match reference image

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        const dpr = Math.min(window.devicePixelRatio ? window.devicePixelRatio : 1, 2);
        renderer.setPixelRatio(dpr);
        renderer.setClearColor(0x000000, 0);
        container.appendChild(renderer.domElement);

        function resizeRenderer() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const resizeObserver = new ResizeObserver(() => {
            resizeRenderer();
        });
        resizeObserver.observe(container);

        setTimeout(() => {
            resizeRenderer();
        }, 100);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Store initial camera position and target for reset
        const initialCameraPosition = camera.position.clone();
        const initialControlsTarget = new THREE.Vector3(0, 0, 0);

        // Function to reset camera to initial position
        function resetCamera() {
            camera.position.copy(initialCameraPosition);
            controls.target.copy(initialControlsTarget);
            controls.update();
            console.log('three_viewer: Camera reset to initial position');
        }

        // Limit vertical rotation angle (polar angle)
        // 0 = straight down, PI = straight up, PI/2 = horizon
        controls.minPolarAngle = Math.PI * 0.15; // ~27째 from top (prevent looking straight down)
        controls.maxPolarAngle = Math.PI * 0.85; // ~153째 from top (prevent looking straight up)

        console.log('three_viewer: Vertical viewing angle limited to',
            Math.round(controls.minPolarAngle * 180 / Math.PI), '째 to',
            Math.round(controls.maxPolarAngle * 180 / Math.PI), '째');

        // Enable shadows on the renderer
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Improved Lighting Setup
        // 1. Hemisphere Light - simulates sky/ground ambient lighting
        const hemisphereLight = new THREE.HemisphereLight(
            0xffffff, // sky color (white)
            0x444444, // ground color (dark gray)
            0.6       // intensity
        );
        scene.add(hemisphereLight);

        // 2. Main Directional Light - acts like the sun, casts shadows
        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(5, 10, 7);
        mainLight.castShadow = true;

        // Configure shadow properties for better quality
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        mainLight.shadow.camera.near = 0.5;
        mainLight.shadow.camera.far = 50;
        mainLight.shadow.camera.left = -10;
        mainLight.shadow.camera.right = 10;
        mainLight.shadow.camera.top = 10;
        mainLight.shadow.camera.bottom = -10;
        scene.add(mainLight);

        // 3. Fill Light - softer light from the opposite side
        const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
        fillLight.position.set(-5, 5, -5);
        scene.add(fillLight);

        // 4. Rim/Back Light - adds definition to edges
        const rimLight = new THREE.PointLight(0xffffff, 0.5);
        rimLight.position.set(-3, 3, -8);
        scene.add(rimLight);

        // Create Ground Plane
        const groundGeometry = new THREE.PlaneGeometry(20, 20);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,        // Solid white
            roughness: 0.8,
            metalness: 0.1,
            side: THREE.FrontSide   // Only visible from top, invisible from bottom
        });
        const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial);
        groundMesh.rotation.x = -Math.PI / 2; // Rotate to be horizontal
        groundMesh.position.y = -0.8; // Position below the models
        groundMesh.receiveShadow = true; // Ground receives shadows
        scene.add(groundMesh);

        // Optional: Add a subtle grid helper on the ground
        const gridHelper = new THREE.GridHelper(20, 40, 0x888888, 0xcccccc);
        gridHelper.position.y = -0.79; // Slightly above ground to prevent z-fighting
        gridHelper.material.opacity = 0.2;
        gridHelper.material.transparent = true;
        scene.add(gridHelper);

        console.log('three_viewer: Added improved lighting and ground plane');

        // Create separate groups for assembly and disassembly
        const assemblyGroup = new THREE.Group();
        assemblyGroup.name = 'assemblyGroup';
        const disassemblyGroup = new THREE.Group();
        disassemblyGroup.name = 'disassemblyGroup';

        // Track current mode
        let currentMode = initialMode;

        // Store original positions for each disassembly object to recalculate explosions
        const originalPositions = new Map();

        // Function to toggle between modes
        function setMode(mode) {
            currentMode = mode;
            assemblyGroup.visible = (mode === 'assemble');
            disassemblyGroup.visible = (mode === 'disassemble');
            console.log('three_viewer: switched to mode', mode);
        }

        // Listen for messages from Flutter to toggle mode
        window.addEventListener('message', function (event) {
            try {
                const data = event.data;
                let type, mode, distance;

                if (typeof data === 'string') {
                    const parsed = JSON.parse(data);
                    type = parsed.type;
                    mode = parsed.mode;
                    distance = parsed.distance;
                } else if (typeof data === 'object') {
                    type = data.type;
                    mode = data.mode;
                    distance = data.distance;
                }

                if (type === 'toggleMode' && mode) {
                    setMode(mode);
                } else if (type === 'updateDisassemblyDistance' && distance !== undefined) {
                    disassemblyDistance = distance;
                    updateDisassemblyPositions();
                    console.log('three_viewer: Updated disassembly distance to', distance);
                } else if (type === 'resetCamera') {
                    resetCamera();
                }
            } catch (e) {
                // Ignore malformed messages
            }
        });

        // Load all models for both groups
        let totalModelsToLoad = assemblyModels.length + disassemblyModels.length;
        let loadedCount = 0;

        function updateLoadingProgress() {
            loadedCount++;
            setLoadingText(`Loading models... ${loadedCount}/${totalModelsToLoad}`);

            if (loadedCount === totalModelsToLoad) {
                // All models loaded, finalize setup
                finalizeSetup();
            }
        }

        function finalizeSetup() {
            console.log('three_viewer: Finalizing setup...');
            console.log('three_viewer: assemblyGroup has', assemblyGroup.children.length, 'children');
            console.log('three_viewer: disassemblyGroup has', disassemblyGroup.children.length, 'children');

            // Scale each group to fit viewport, but preserve Blender origin
            [assemblyGroup, disassemblyGroup].forEach(group => {
                if (group.children.length > 0) {
                    // Calculate bounding box for the entire group
                    const box = new THREE.Box3().setFromObject(group);
                    const size = box.getSize(new THREE.Vector3());
                    const maxDim = Math.max(size.x, size.y, size.z);

                    console.log('three_viewer: Group', group.name, 'bounding box size:', size, 'maxDim:', maxDim);

                    // DON'T center the group - respect Blender's origin positioning
                    // group.position.sub(center); // REMOVED - this was shifting everything

                    // Only scale to fit viewport (1.5 units)
                    const scale = maxDim > 0 ? (1.5 / maxDim) : 1.0;
                    group.scale.setScalar(scale);


                    if (group.name === 'assemblyGroup') {
                        group.rotation.y = -Math.PI * 70 / 180; // -70 degrees (clockwise from above)
                    }

                    console.log('three_viewer: Group', group.name, 'scaled to:', scale);
                    console.log('three_viewer: Group', group.name, 'position (preserved from Blender):', group.position);
                    console.log('three_viewer: Group', group.name, 'children count:', group.children.length);
                }
            });

            // Apply exploded view displacement to disassembly group
            // Store original positions and calculate initial disassembly
            if (disassemblyGroup.children.length > 0) {
                disassemblyGroup.children.forEach(function (child) {
                    // Calculate the center of this object's geometry
                    const box = new THREE.Box3().setFromObject(child);
                    const center = new THREE.Vector3();
                    box.getCenter(center);

                    // Store original position (before any displacement)
                    originalPositions.set(child.uuid, child.position.clone());

                    // Calculate displacement with per-axis multipliers
                    const explosionMultiplierX = 1.5 * disassemblyDistance;
                    const explosionMultiplierY = 0.5 * disassemblyDistance;
                    const explosionMultiplierZ = 0.5 * disassemblyDistance;

                    const displacement = new THREE.Vector3(
                        center.x * explosionMultiplierX,
                        center.y * explosionMultiplierY,
                        center.z * explosionMultiplierZ
                    );

                    // Apply the displacement to the object's position
                    child.position.add(displacement);

                    console.log('three_viewer: Displaced', child.name || 'object',
                        'center at', center.length().toFixed(2),
                        'by', displacement.length().toFixed(2), 'units');
                });

                console.log('three_viewer: Applied exploded view to disassembly group with distance', disassemblyDistance);
            }

            // Function to update disassembly positions based on slider
            window.updateDisassemblyPositions = function () {
                if (disassemblyGroup.children.length === 0) return;

                disassemblyGroup.children.forEach(function (child) {
                    // Reset to original position
                    const original = originalPositions.get(child.uuid);
                    if (!original) return;

                    child.position.copy(original);

                    // Recalculate displacement with new distance
                    const box = new THREE.Box3().setFromObject(child);
                    const center = new THREE.Vector3();
                    box.getCenter(center);

                    const explosionMultiplierX = 1.5 * disassemblyDistance;
                    const explosionMultiplierY = 0.5 * disassemblyDistance;
                    const explosionMultiplierZ = 0.5 * disassemblyDistance;

                    const displacement = new THREE.Vector3(
                        center.x * explosionMultiplierX,
                        center.y * explosionMultiplierY,
                        center.z * explosionMultiplierZ
                    );

                    child.position.add(displacement);
                });
            };

            // Add both groups to scene
            scene.add(assemblyGroup);
            scene.add(disassemblyGroup);

            // Set initial visibility
            setMode(currentMode);

            loadingEl.style.display = 'none';
            startLoop();
            console.log('three_viewer: All models loaded and ready!');
            console.log('three_viewer: Assembly group visible:', assemblyGroup.visible);
            console.log('three_viewer: Disassembly group visible:', disassemblyGroup.visible);
        }

        function loadModelGroup(models, mtls, targetGroup) {
            if (models.length === 0) {
                // No models to load for this group
                return;
            }

            function loadSingleModel(idx) {
                if (idx >= models.length) {
                    return; // Done with this group
                }

                const path = models[idx];
                const lower = path.toLowerCase();
                const encodedPath = encodeURI(path);

                const finalize = function (obj) {
                    obj.userData = obj.userData || {};
                    obj.userData.source = path;
                    obj.traverse(function (child) {
                        if (child.isMesh) {
                            child.userData = child.userData || {};
                            child.userData.source = path;
                            // Enable shadow casting and receiving for all meshes
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    targetGroup.add(obj);
                    updateLoadingProgress();
                    loadSingleModel(idx + 1);
                };

                if (lower.endsWith('.glb') || lower.endsWith('.gltf')) {
                    const gltfLoader = new THREE.GLTFLoader();
                    gltfLoader.load(encodedPath, function (gltf) {
                        const obj = gltf.scene || gltf.scenes[0];
                        finalize(obj);
                    }, null, function (err) {
                        console.error('GLTF load error for', encodedPath, err);
                        updateLoadingProgress();
                        loadSingleModel(idx + 1);
                    });
                } else {
                    const mtlToUse = mtls[idx] || null;
                    const onObjLoaded = function (obj) {
                        obj.traverse(function (child) {
                            if (!child.isMesh || !child.material) return;
                            const mat = child.material;

                            // If already a standard material, just update it
                            if (mat.type === 'MeshStandardMaterial') {
                                mat.needsUpdate = true;
                                return;
                            }

                            // Convert to MeshStandardMaterial with proper PBR values
                            const std = new THREE.MeshStandardMaterial({
                                color: mat.color ? mat.color.clone() : new THREE.Color(0xcccccc),
                                side: THREE.DoubleSide,
                                metalness: 0.1,
                                roughness: 0.8,
                            });

                            // Copy textures from MTL material
                            if (mat.map) std.map = mat.map;
                            if (mat.bumpMap) std.normalMap = mat.bumpMap;
                            if (mat.normalMap) std.normalMap = mat.normalMap;
                            if (mat.specularMap) std.roughnessMap = mat.specularMap;
                            if (mat.envMap) std.metalnessMap = mat.envMap;
                            if (mat.metalnessMap) std.metalnessMap = mat.metalnessMap;

                            if (std.metalnessMap) std.metalness = 0.5;
                            if (std.roughnessMap) std.roughness = 0.9;
                            if (std.normalMap) std.normalScale = mat.normalScale || new THREE.Vector2(1, 1);

                            std.opacity = mat.opacity !== undefined ? mat.opacity : 1.0;
                            std.transparent = !!mat.transparent;
                            std.needsUpdate = true;
                            child.material = std;
                        });
                        finalize(obj);
                    };

                    const loadObjWithMaterials = function (materials) {
                        const objLoader = new THREE.OBJLoader();
                        if (materials) objLoader.setMaterials(materials);
                        objLoader.load(encodedPath, onObjLoaded, null, function (err) {
                            console.error('OBJ load error for', encodedPath, err);
                            updateLoadingProgress();
                            loadSingleModel(idx + 1);
                        });
                    };

                    if (mtlToUse) {
                        const encodedMtl = encodeURI(mtlToUse);
                        const mtlLoader = new THREE.MTLLoader();
                        mtlLoader.load(encodedMtl, function (materials) {
                            materials.preload();
                            loadObjWithMaterials(materials);
                        }, null, function (err) {
                            console.warn('MTL load failed for', encodedMtl, err);
                            loadObjWithMaterials(null);
                        });
                    } else {
                        loadObjWithMaterials(null);
                    }
                }
            }

            loadSingleModel(0);
        }

        // Start loading both groups
        if (totalModelsToLoad === 0) {
            setLoadingText('No models specified');
        } else {
            loadModelGroup(assemblyModels, assemblyMtls, assemblyGroup);
            loadModelGroup(disassemblyModels, disassemblyMtls, disassemblyGroup);
        }

        // Raycaster for click detection
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();
        const tooltip = document.getElementById('tooltip');
        let hoveredObject = null;
        let originalMaterials = new Map(); // Store original materials for hover effect

        // Click vs drag detection
        let pointerDownPos = { x: 0, y: 0 };
        let isDragging = false;
        const DRAG_THRESHOLD = 5; // pixels

        // Map file paths to display names
        const partDisplayNames = {
            'blt150_02': 'Right Side Mirror',
            'blt150_03': 'Left Side Mirror',
            'blt150_04': 'Handle Bar',
            'blt150_05': 'Front Frame',
            'blt150_06': 'Back Frame',
            'blt150_07': 'Front Wheel',
            'blt150_08': 'Rear Fender',
            'blt150_09': 'Exhaust Pipe',
            'blt150_10': 'Rear Wheel',
            'blt150_11': 'Rear Shock Absorber'
        };

        // Function to extract part name from path
        function getPartNameFromPath(path) {
            if (!path) return 'Unknown Part';
            const fileName = path.split('/').pop();
            const nameWithoutExt = fileName.replace(/\.(obj|glb|gltf)$/i, '');

            // Check if we have a mapped display name
            if (partDisplayNames[nameWithoutExt]) {
                return partDisplayNames[nameWithoutExt];
            }

            // Fallback: Convert underscores/hyphens to spaces and capitalize
            return nameWithoutExt
                .replace(/[_-]/g, ' ')
                .replace(/\b\w/g, char => char.toUpperCase());
        }

        // Highlight effect - store original material and apply emissive glow
        function highlightObject(object) {
            if (!object || hoveredObject === object) return;

            // Remove previous highlight
            if (hoveredObject) {
                unhighlightObject(hoveredObject);
            }

            hoveredObject = object;

            object.traverse(child => {
                if (child.isMesh && child.material) {
                    // Store original material properties
                    if (!originalMaterials.has(child.uuid)) {
                        originalMaterials.set(child.uuid, {
                            emissive: child.material.emissive ? child.material.emissive.clone() : new THREE.Color(0x000000),
                            emissiveIntensity: child.material.emissiveIntensity || 0
                        });
                    }

                    // Apply highlight - primary blue glow
                    child.material.emissive = new THREE.Color(0x399ADE);
                    child.material.emissiveIntensity = 0.4;
                    child.material.needsUpdate = true;
                }
            });
        }

        // Remove highlight effect
        function unhighlightObject(object) {
            if (!object) return;

            object.traverse(child => {
                if (child.isMesh && child.material) {
                    const original = originalMaterials.get(child.uuid);
                    if (original) {
                        child.material.emissive = original.emissive.clone();
                        child.material.emissiveIntensity = original.emissiveIntensity;
                        child.material.needsUpdate = true;
                    }
                }
            });

            hoveredObject = null;
        }

        // Show tooltip
        function showTooltip(x, y, text) {
            tooltip.style.display = 'block';
            tooltip.textContent = text;
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            tooltip.style.display = 'none';
        }

        // Mouse move handler for hover detection
        function onPointerMove(event) {
            // Track dragging
            if (pointerDownPos.x !== 0 || pointerDownPos.y !== 0) {
                const dx = event.clientX - pointerDownPos.x;
                const dy = event.clientY - pointerDownPos.y;
                if (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD) {
                    isDragging = true;
                }
            }

            // Only enable hover in disassemble mode
            if (currentMode !== 'disassemble') {
                hideTooltip();
                if (hoveredObject) {
                    unhighlightObject(hoveredObject);
                }
                renderer.domElement.style.cursor = 'default';
                return;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(disassemblyGroup.children, true);

            if (intersects && intersects.length > 0) {
                const topObject = intersects[0].object;

                // Find the top-level parent in disassemblyGroup
                let targetObject = topObject;
                while (targetObject.parent && targetObject.parent !== disassemblyGroup) {
                    targetObject = targetObject.parent;
                }

                const source = targetObject.userData?.source ||
                    topObject.userData?.source ||
                    topObject.parent?.userData?.source;

                if (source) {
                    // Show highlight and tooltip
                    highlightObject(targetObject);
                    showTooltip(event.clientX, event.clientY, getPartNameFromPath(source));
                    renderer.domElement.style.cursor = 'pointer';

                    // Notify Flutter of hover
                    window.parent.postMessage({
                        type: 'partHover',
                        model: source,
                        partName: getPartNameFromPath(source)
                    }, '*');
                } else {
                    hideTooltip();
                    if (hoveredObject) {
                        unhighlightObject(hoveredObject);
                    }
                    renderer.domElement.style.cursor = 'default';
                }
            } else {
                hideTooltip();
                if (hoveredObject) {
                    unhighlightObject(hoveredObject);
                }
                renderer.domElement.style.cursor = 'default';
            }
        }

        function onPointerDown(event) {
            // Record pointer down position to detect dragging
            pointerDownPos.x = event.clientX;
            pointerDownPos.y = event.clientY;
            isDragging = false;
        }

        function onPointerUp(event) {
            // Only register click if not dragging and in disassemble mode
            if (isDragging || currentMode !== 'disassemble') {
                pointerDownPos = { x: 0, y: 0 };
                isDragging = false;
                return;
            }

            const rect = renderer.domElement.getBoundingClientRect();
            pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(pointer, camera);
            // Use disassemblyGroup for consistent click detection with hover
            const intersects = raycaster.intersectObjects(disassemblyGroup.children, true);

            if (intersects && intersects.length > 0) {
                const topObject = intersects[0].object;

                // Find the top-level parent in disassemblyGroup
                let targetObject = topObject;
                while (targetObject.parent && targetObject.parent !== disassemblyGroup) {
                    targetObject = targetObject.parent;
                }

                const source = targetObject.userData?.source ||
                    topObject.userData?.source ||
                    topObject.parent?.userData?.source;

                if (source) {
                    console.log('three_viewer: Part clicked:', source);
                    window.parent.postMessage({ type: 'partClick', model: source }, '*');
                }
            }

            pointerDownPos = { x: 0, y: 0 };
            isDragging = false;
        }

        renderer.domElement.addEventListener('pointermove', onPointerMove);
        renderer.domElement.addEventListener('pointerdown', onPointerDown);
        renderer.domElement.addEventListener('pointerup', onPointerUp);

        // Animation loop
        let rafId = null;
        let running = !document.hidden;
        function startLoop() {
            function animate() {
                if (!running) return;
                rafId = requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            if (running) animate();
        }

        document.addEventListener('visibilitychange', function () {
            running = !document.hidden;
            if (running && !rafId) startLoop();
            if (!running && rafId) {
                cancelAnimationFrame(rafId);
                rafId = null;
            }
        });

        window.addEventListener('resize', function () {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Keyboard shortcuts
        window.addEventListener('keydown', function (event) {
            // Press 'R' or 'r' to reset camera
            if (event.key === 'r' || event.key === 'R') {
                resetCamera();
            }
        });
    </script>
</body>

</html>